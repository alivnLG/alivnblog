---
title: 正则表达式一手掌握
date: 2020-12-21 10:23:58
top: true
tags:
- 正则表达式
categories:
- JavaScript
---
#### 一、常用字符

正则中很多需要强记的字符，这里列出常用的字符和其表达的含义：
<!--more-->
常用匹配字符 | 含义
-- | --
[0-9] | 匹配单个数字0-9
[a-z] | 匹配单个小写字母
[A-Z] | 匹配单个大写字母
\s | 匹配所有空白字符，如空格、换行等
\n | 匹配所有换行符
\b | 匹配边界如字符之间的空格

#### 二、特殊字符

特殊字符 | 含义 | 用法
-- | -- | --
^ | 1. 匹配输入字符串的开始位置<br/>2. 用在[]中时表示 非 | 1. /^http/ 匹配以http开头的字符串<br/>2. /[^a-zA-Z]/ 匹配非字母
$ | 匹配输入字符串的结尾位置 | /.com$/ 匹配以.com结尾的字符串
\| | 二选一，表示 或 | /a\|b/ 匹配a或者b
. | 小数点匹配换行符\n之外的任何单个字符 | /./ 匹配换行符之外的其他字符
[] | 中括号匹配一个字符 | /[aeiou]/ 匹配字母 aeiou 中的一个
() | 小括号表示一个子表达式分组 | 匹配的子表达式可以用于以后使用
{} | 大括号表示限定一个表达式多少次 | {n} 匹配n次; {n,} 匹配最少n次; {n, m} 匹配n-m次
+ | 匹配前面的子表达式一次或多次 | /[0-9]+/ 匹配一个数字或多个数字
* | 匹配前面的子表达式零次或多次 | /[0-9]*/ 匹配0次数字或多个数字
? | 1. 匹配前面的子表达式零次或一次<br/>2. 指明一个非贪婪限定符 | 1. /[0-9]?/<br/>2. /<.*?>/ 匹配一个标签如```<p>```

##### 2.1 匹配特殊字符本身时需要转义

```js
* . ? + $ ^ [ ] ( ) { } | \ /
```

其中 / 在字面量中需要转义，在构造函数中不需要，如下匹配一个斜杠 /。

```js
const reg = /\//
const reg = new RegExp('/')
```

在字面量中带一个转义符 \ 的用构造函数写要带两个转义符 \\，如下匹配一个字符串 . 。

```js
const reg = /\./
const reg = new RegExp('\\.')
```

#### 三、常用方法

js 中的正则表达式分为字面量和构造函数两种：

```js
// 字面量
const reg = /[0-9a-z]/g
// 构造函数
const reg = new RegExp('[0-9a-z]', 'g')
```

其中字面量中不能包含变量，构造函数中可以使用变量：

```js
const name = '幻灵尔依'
const reg = new RegExp(`我的名字叫${name}`)
```

经常会用 reg.test(str) 方法来判断字符串中是否匹配到了正则表达式：

```js
const reg = /[0-9]/
const str = '文本中有没有数字1234等'
if (reg.test(str)) {
  ...
}
```

也经常用str.replace(reg, '') 方法来替换字符串中的内容：

```js
const reg = /[0-9]/g
const str = '文本中的数字1234全部替换成x'
const newStr = str.replace(reg, 'x')
```

也会用到 str.match(reg) 方法来获取匹配到的内容（也可以用reg.exec(str)）：

```js
const reg = /[0-9]+[.][0-9]+[.][0-9]+/g
const str = '这里有个表名字叫做 11.11.11'
str.match(reg) // ['11.11.11']
```

match 中的正则表达式如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。

如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。

#### 四、贪婪&非贪婪

\* 和 + 限定符都是贪婪的，它们会尽可能多的匹配文字。在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。

贪婪（默认都是贪婪的）

```js
const str = '<h1>正则表达式</h1>'
const reg = /<.*>/
str.match(reg) // ['<h1>正则表达式</h1>']
```

非贪婪

```js
const str = '<h1>正则表达式</h1>'
const reg = /<.*?>/
str.match(reg) // ['<h1>']
```

#### 五、捕获分组和回溯引用

小括号 () 匹配到的子表达式会被缓存为一个个组，方便后面对其引用。假设要获取html中的 h1 标签：

在正则表达式中使用 \n 可以引用第n个捕获组

```js
const str = '<p>正则表达式</p><h1>正则表达式</h1><h2>正则表达式</h2>'
const reg = /<(h1)>.+?<\/\1>/
str.match(reg) // ['<h1>正则表达式</h1>']
```

在正则表达式外使用 $n 引用第n个捕获组（RegExp.$n）

```js
const str = 'abc'
const reg = /(abc)/
RegExp.$1 // 'abc'
str.replace(reg, '$1$1') // 'abcabc'
```

#### 六、非捕获分组和限定查找

因为捕获组 () 会将每个捕获到的结果缓存下来以便引用，所以会造成内存使用增加。如果只是想用分组的原始功能，而不需要缓存，则可以使用非捕获分组 (?:)

```js
const str = 'abc'
const reg = /(?:abc)/
RegExp.$1 // ''
```

非捕获分组还有 (?=)、(?<=)、(?!)、(?<!) ，他们比 (?:) 多了限定作用，即只匹配而不会被输出。

##### 6.1 前向查找

前向查找是用来限制后缀的。

（1）(?=)： 即查找符合限定条件 (?=) 的前面的匹配项（输出内容不包括 (?=) 中的匹配项）

```js
const str = 'a.png b.jpg c.gif d.svg'
// 查找所有 边界开头的、 .svg 前面的 小写字母。
const reg = /\b[a-z](?=.svg)/g
str.match(reg) // ['d']
```

（2）(?!)： 即查找 不符合 限定条件 (?!) 的前面的匹配项（输出内容不包括 (?!) 中的匹配项）

```js
const str = 'a.png b.jpg c.gif d.svg'
// 查找所有边界开头的、 非.svg 前面的、 `.[a-z]{3}` 前面的 小写字母。
const reg = /\b[a-z](?!.svg)(?=\.[a-z]{3})/g
str.match(reg) // ['a', 'b', 'c']
```

##### 6.2 后向查找

后向查找是用来限制前缀的。

（1）查找符合限定条件 (?<=) 的后面的匹配项（输出内容不包括 (?<=) 中的匹配项）

```js
const str = '1. 1111； 2. 2222； 3. 3333； 4. 4444。'
//  查找所有 序号 后面的项。
const reg = /(?<=\b[0-9]+\.\s).+?[；。]/g
str.match(reg) // ["1111；", "2222；", "3333；", "4444。"]
```

（2）查找 不符合 限定条件 (?<!) 的后面的匹配项（输出内容不包括 (?<!) 中的匹配项）

```js
const str = 'a.png b.jpg c.gif d.svg'
// 查找前缀不为 a b c 的后面的项
const reg = /\b(?<![abc]\.)[a-z]{3}/g
str.match(reg) // ['svg']
```

#### 七、示例

##### 7.1 前向查找和后向查找齐用

假设要获取 ```<img crossorigin src="https://abcdefg.com" data-img-url="https://test.com">```中的 data-img-url 属性中的链接。可以确定的是链接左边一定是 data-img-url=" ，右边一定是紧贴着 " （非贪婪）。

```js
const str = '<img crossorigin src="https://abcdefg.com" data-img-url="https://test.com">'
const dataImgUrl = 'data-img-url'
const reg = new RegExp(`(?<=${dataImgUrl}=").+?(?=")`, 'g')
str.match(reg) // ['https://test.com']
```

##### 7.2 回溯引用和非贪婪并用

假如我要获取一段html中的文本，但是我又不想要加了 not-show-in-text 标记的标签中的文本，可以这样：

```js
const notShowInText = 'not-show-in-text'
const html = `
  <p>test1</p>
  <p ${notShowInText} style="text-align: center;">
    <b>表 1.4.4 测试表格</b>
  </p>
  <p>test2</p>
`
const reg = new RegExp(`<([a-z][a-z1-6]*?)[^>]+${notShowInText}[\\s\\S]+?</\\1>`, 'g')
const text = html.replace(reg, '').replace(/<[^>]+>/g, '')
```

其中最关键的是要匹配到 not-show-in-text 所在的整个标签。([a-z][a-z1-6]*?) 匹配了一个非贪婪的标签名，[^>] 保证了 < 到 > 是一个半个完整的标签，</\\1> 匹配一个闭合的标签， [\\s\\S]+? 匹配了标签见可能出现的任意元素且是非贪婪的。

##### 7.3 replace第二个参数可以是回调函数

比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result); // "06/12/2017"
```

其中 replace 第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function() {
	return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result); // "06/12/2017"
```

也等价于：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function(match, year, month, day) {
	return month + "/" + day + "/" + year;
});
console.log(result); // "06/12/2017"
```

<br/>
<br/>
<br/>

转载自：[https://juejin.cn/post/6907143412227522567](https://juejin.cn/post/6907143412227522567)

