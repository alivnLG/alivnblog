---
title: 前端基础
date: 2020-05-29 09:57:11
tags:
- HTML
- CSS
- JS
categories: 
- Web前端
---
#### 1.HTML（Hyper Text Markup Language 超文本标记语言）
#### 2.HTML版本
<!--more-->
HTML4.0 --> XHTML（规范严格） --> HTML5
#### 3.CSS Hack
##### CSS Hack简介
由于不同厂商的浏览器，比如Internet Explorer、Chrome、Mozilla Firefox、Safari等，或者是统一厂商的浏览器的不同版本，比如IE6和IE7，对CSS的解析和认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。这个时候，我们就需要针对不同的浏览器，去写不同CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中，也能得到我们想要的页面效果。

##### 为什么使用CSS Hack
简单的说，CSS Hack的目的，就是使你的CSS代码兼容不同的浏览器。当然，我们也可以反过来利用CSS Hack为不同版本的浏览器定制编写不同的CSS效果。

##### 原理
由于不同的浏览器对CSS的支持和解析结果不一样，还由于CSS中的优先级关系，我们就可以根据这个来针对不同的浏览器来写不同的CSS。

##### 表现形式
注意：CSS Hack 主要针对类内部hack.
###### 属性前缀法（CSS类内部 Hack）
比如IE6能识别下划线"_"和星号"*" ，IE7能识别星号"*"，但不能识别下划线,IE6-IE10都认识"\9",而Firefox这三个都不能认识。

对于书写顺序的关系，一般是将识别能力强的浏览器的CSS写在后边
```
<style> 
div{  
    background:green;/*forfirefox*/  
    *background:red;/*forIE6 IE7*/  
}  
</style> 
```
###### 选择器前缀法（选择器 Hack）
```
:root .test
{
    background-color:green;
}
```
###### IE条件注释法（HTML 头部引用 Hack), 针对所有IE（注：IE10+已经不再支持条件注释）
HTML头部引用就比较特殊了，类似于程序语句，只能使用在HTML文件里，而不能在CSS文件中使用，并且只有在IE浏览器下才能执行，在其他浏览器下面会被当做注释视而不见。
```
<link rel="stylesheet" type="text/css" href="css.css" />
<!–[if IE 7]>
<!– 如果IE浏览器版是7,调用ie7.css样式表 –>
<link rel="stylesheet" type="text/css" href="ie7.css" />
<![endif]–>
<!–[if lte IE 6]>
<!– 如果IE浏览器版本小于等于6,调用ie.css样式表 –>
<link rel="stylesheet" type="text/css" href="ie.css" />
<![endif]–>
```
```
<!--[if IE]>IE浏览器显示的内容<![endif]--> 
 <!--[if lt IE6]>只在IE6及以下版本显示的内容<![endif]-->
```
在属性值后面添加“!important”的写法只有IE6不能识别，其它版本IE及现代浏览器都可以识别;
```
background-color:green!important;
```

#### 4.JavaScript 异步机制
##### 同步与异步
![web001](https://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/web001.jpg)
*同步*  

如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。
```
//在函数返回时，获得了预期值，即2的平方根
Math.sqrt(2);
//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'
console.log('hello');
```
如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。

*异步*

如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。
```
//读取文件
fs.readFile('hello.txt', 'utf8', function(err, data) {
    console.log(data);
});
//网络请求
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = xxx; // 添加回调函数
xhr.open('GET', url);
xhr.send(); // 发起函数
```
如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。

##### 单线程与多线程
![web002](https://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/web002.jpg)

JavaScript是单线程

JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。

浏览器的内核是多线程的；

虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown...）等都是由浏览器提供的其他线程来完成的。

##### 消息队列与事件循环
通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？

需要继续了解消息队列和事件循环

![web003](https://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/web003.jpg)

如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。

右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。

JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。

JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。

![web004](https://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/web004.jpg)

上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。

#### 5.JavaScript 最佳实践
##### 使用 === 代替 ==
##### 避免使用Eval
大幅降低脚本的性能，而且这也会带来巨大的安全风险，因为这样付给要执行的文本太高的权限，避而远之。
##### 省略未必省事
##### 使用JSLint
找出代码中明显的问题和错误。
##### 将脚本放在页面的底部
首要目标是让页面尽可能快的呈献给用户，脚本的夹在是阻塞的，脚本加载并执行完之前，浏览器不能继续渲染下面的内容。因此，用户将被迫等待更长时间。
##### 避免在For语句内声明变量
##### 构建字符串的最优方法
##### 减少全局变量
##### 给代码添加注释
##### 拥抱渐进增强
##### 不要给"setInterval"或"setTimeout"传递字符串参数
##### 不要使用"with"语句
##### 使用{}代替 new Ojbect()
```
var o = new Object();  
o.name = 'Jeffrey';  
o.lastName = 'Way';  
o.someFunction = function() {  
   console.log(this.name);  
}
```
```
var o = {  
   name: 'Jeffrey',  
   lastName = 'Way',  
   someFunction : function() {  
      console.log(this.name);  
   }  
};
```
##### 使用[]代替 new Array()
```
var a = new Array();  
a[0] = "Joe";  
a[1] = 'Plumber'; 
```
```
var a = ['Joe','Plumber']; 
```
##### 定义多个变量时，省略var关键字，用逗号代替
##### 谨记，不要省略分号
##### "For in"语句
##### 使用Firebug的"timer"功能优化你的代码
##### 阅读，阅读，反复阅读
##### 自执行函数
```
(function doSomething() {  
   return {  
      name: 'jeff',  
      lastName: 'way'  
   };  
})(); 
```
##### 原生代码永远比库快
##### JSON.Parse
##### 移除"language"属性

#### 6.JavaScript 事件冒泡与捕获
微软提出了事件冒泡(event bubbling)的事件流，即事件从最内层的元素开始，一层层往上传播，直到document结束。与之相对应的网景提出了名为事件捕获(event capturing)的事件流,即事件从最外层的元素开始也就是从document开始一层层往下传递。

在javascript中，使用addEventListener()来给元素绑定事件。
```
EventTarget.addEventListener(type,listener,useCapture)

type：需要监听的事件类型

listener：事件触发之后执行的函数

useCapture：默认为false，表示使用事件冒泡，即div2先被
点击；设置为true，表示使用事件捕获，即div1先被点击
```
在jquery中，不支持事件捕获，仅仅支持事件冒泡

jquery提供了停止事件冒泡的方法：event.stopPropagation()；可以阻止事件中其他对象的事件处理函数被执行。

jquery还提供了阻止默认行为的方法:event.preventDefault()；例如：提交表单的时候，对表单进行前端验证，验证不通过的时候，阻止表单提交 ，就可以使用此方法。

#### 7.HTTPS
超文本传输安全协议（HTTPS，常称为 HTTP over TLS/SSL）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

TCP (Transmission Control Protoco) 传输层控制协议

TLS (Transport Layer Security) 传输层安全协定

SSL (Secure Socket Layer) 安全套接层

HTTP(Hypertext Transfer Protocol) 基于 TCP 协议，无连接，每次连接只处理一个请求，结束后断开连接；无状态，无法保持用户状态，使用 cookie 和 session 解决。

HTTPS(HTTP over TLS/SSL) 安全的 http 协议，HTTP 协议和 TCP 协议之间增加了 TLS/SSL 保证数据的安全传输。

#### 8.模板引擎
模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。

就是将模板文件和数据通过模板引擎生成一个HTML代码

[art-template](https://github.com/aui/art-template)

[juicer](https://github.com/PaulGuo/Juicer)

[doT](https://github.com/olado/doT)

[BaiduTemplate](http://baidufe.github.io/BaiduTemplate/)

#### 9.FPS
FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。
#### 10.轮询机制与心跳
轮询：服务器定时主动的去与要监控的客户端通信，询问当前某种状态，客户端返回状态信息，客户端没有返回或返回错误，则认为客户端已经宕机。如果客户端宕机之后重启了，那么当服务端定时来轮询的时候，还是可以正常的获取返回信息，把其状态重新更新。

心跳：客户端定时访问服务器，更新自己的当前状态，如果客户端超过指定的时间没有来更新状态，则认为客户端已经宕机。
可以避免服务器压力

通过socket流，定时发送信息到服务器某个接口，服务端收到后更新当前的客户端的状态，本次来更新的时间就是心跳时间，然后服务端还有一个定时器，定时检查所有缓存的客户端会话集合，将其中的心跳时间与当前时间进行对比，如果超过指定的时间还没有来更新则认为该客户端的网络出现异常或宕机。

```
function setTimer () {
         let timer
        axios.post(url, params)
        .then(function (res) {
            if(res){
                console.log(res);
                timer = setTimeout(() => {
                    this.setTimer()
                }, 5000)       
            }else {
                clearTimeout(timer) //清理定时任务
            }
            
        })
        .catch(function (error) {
                console.log(error);
        });
},
```
#### 11.CORS-跨域资源共享
它允许浏览器向跨源服务器，发出ajax请求，从而克服了AJAX只能同源使用的限制。

CORS依赖于服务器端的设定，只要在服务器端进行了设置，就可以实现相应的资源访问。

#### 12.跨域-JSONP
##### script
jsonp的原理：script标签具有跨域性，可以利用Script标签的src属性发送跨域请求，获取相应数据；
```
<script src="域名/域名下的php文件名?callbackName=fnName"></script>
<script>
    // 回调函数
    function fnName(data){
        console.log(data);
    }
</script>
```
##### jQuery-jsonp
type必须是get
```
$.ajax({
    url: "域名/域名下的php文件名",
    dataType: "jsonp",
    jsonp: "callbackName",  // 约定等号左边的key，服务器根据该名称获取回调函数名称
    jsonpCallback: "fnName", // 约定等号右边的value，标识回调函数名称
    success: function(){
        // todo
    },
    error: function(){
        // todo
    }
})
```
```
function myAjax(options) {
  // 默认值
  var defaults = {
      jsonp: "callback",
      jsopCallback: "jQuery"+ ('v3.1.1'+ Math.random()).replace(/\D/g,'')+"_"+new Date().getTime();
  };
  // window是全局对象，[]中的值可以是变量，也可以是字符串
  window[defaults.jsonpCallback] = function(data){
      defaults.success(data);
  };
  // 处理业务参数,把data数据转换为查询字符串
  var param = '';
  if(defaults.data){
      for(var key in defaults.data){
          param += key+"="+defaults.data[key]+"&";
      }
  }
  
  // 使用设置参数覆盖默认配置
  for(var key in options){
      defaults[key] = options[key];
  };
  // 处理跨域请求
  var script = document.createElement("script");
  script.src = defaults.url+"?"+ param + defaults.jsonp+"="+defaults.jsonpCallback;
  var head = document.querySelector("head");
  head.appendChild(script);
}
```

#### 13.跨域-服务端代理
在服务器端设置一个代理，由服务器端向跨域下的网站发出请求，再将请求结果返回给前端，成功避免同源策略的限制。

1、在localhost:81/a.html中，向同源下的某个代理程序发出请求
```
$.ajax({
    url:'/proxy.php?name=hello&info=information',   //服务器端的代理程序
    type:'GET',
    success:function (){}

})
```
2、在代理程序proxy.php中，向非同源下的服务器发出请求，获得请求结果，将结果返回给前端。
```
<?php 
$name=$_GET['name'];
$info = $_GET['info'];
$crossUrl = 'http://b.com/sub?name='.$name;   //向其他域下发出请求
$res = file_get_contents($crossUrl);
echo $res; 
 ?>
```

#### 14.富文本基本原理
##### 1.contenteditable 属性
```
<div contenteditable="true"></div>
```
那么在这个 div 中我们就可以对其进行任意编辑了。如果想要插入的子节点不可编辑，我们只需要把子节点的属性设置为 contenteditable="false" 即可;

##### 2.document.execCommand 方法
```
// document.execCommand(命令名称，是否展示用户界面，命令需要的额外参数)

document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)
```
```
// 加粗

document.execCommand('bold', false, null);

// 添加图片

document.execCommand('insertImage', false, url || base64);

// 把一段文字用 p 标签包裹起来

document.execCommand('formatblock', false, '<p>');
```
##### 3.Selection 和 Range 对象
执行 document.execCommand 这个命令之前首先要知道对谁执行，所以这里会有一个选区的概念，也就是 Selection 对象，它用来表示用户选择的范围或光标位置（光标可以看做是范围重合的特殊状态），一个页面用户可能选择多个范围（比如 Firefox）。也就是说 Selection 包含一个或多个 Range 对象（ Selection 可以说是 Range 的集合），当然对于富文本编辑器来说，一般情况下，我们只会有一个选择区域，也就是一个 Range 对象，事实上大部分情况也是如此。

所以通常我们可以用 letrange=window.getSelection().getRangeAt(0) 来获取选中的内容信息（ getRangeAt 接受一个索引值，因为会有多个 Range，而现在只有一个，所以写0）。

![web005](https://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/web005.jpg)

![web006](https://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/web006.jpg)

通过上面那句命令我们能够获取到当前的选中信息，一般会先保存下来，然后在需要的时候还原。此外 Selection 对象还有几个常用的方法， addRange、 removeAllRanges、 collapse 和 collapseToEnd 等等。

#### 15.CSS Module
##### 简介
在css中，代码复用只是一个小的方面，更重要的是解决局部作用域的概念，也就是为了避免全局的样式污染。
```
index.css
  ├─ header.css
  │   └─ reset.css
  ├─ content.css
  │   ├─ left.css
  │   │   └─ nav.css
  │   └─ right.css
  ├─ fotter.css
  └─ ...
```
##### 解决问题

全局污染

命名混乱

层级结构不清晰

代码难以复用

代码压缩不彻底

##### 原理
主要是围绕AST语法树、Vue scoped和React Css module来介绍的。

首先介绍一下AST语法树，因为在webpack里面，我们的css还是js都会解释成AST语法树。它其实就是json的一个数据结构。

###### AST语法树
```
{
 nodes: [{
 raws: {
 before: '',
 between: '',
 semicolon: true,
 after: '\r\n'
 },
 type: 'rule',
 source: {
 start: {
 line: 1,
 column: 1
 },
 input: {
 css: '.header {\r\n  display: flex;\r\n  lost-column: 1/1;\r\n}\r\n',
 hasBOM: false,
 file: '../../../xiaokedao'
 },
 end: {
 line: 4,
 column: 1
 }
 },
 selector: '.header',
 lastEach: 14,
 indexes: {},
 nodes: []
 }]
}
```
###### Vue scoped
```
<div data-v-2311c06a class="button-warp"></div>
​
.button-warp[data-v-2311c06a]{
 display: inline-block;
}
```
###### React Css module
```
<div class="wrapper___2IPqp"></div>
```
##### CSS作用域
###### 局部作用域
webpack 自带的 css-loader 组件，自带了 CSS Modules，通过简单的配置即可使用。
```
module: {
 rules: [
 {
   test: /\.css$/,
   use: ExtractTextPlugin.extract({
   fallback: "style-loader",
   use: [
   {
     loader: 'css-loader',
     options: {
     modules: true,
     }
     }
    ],
   })
  }
 ]
}
```
###### 全局作用域
```
:global(.main) {
 display: flex;
}
```
###### 类组合
```
.header {
 background: #8A469B;
}
​
.footer {
 composes: header;
}
```
###### 哈希规则
```
默认 - [hash:base64]

[path][name][local][hash:base64:n]

[path][hash:base64:n]

[name][hash:base64:n]

[local][hash:base64:n]
```
###### 变量
```
npm install postcss-modules-values

{
    loader: "postcss-loader",
    "options": {
        plugins: [
            require('postcss-modules-values'),
        ]
    }
}


@value color: #8A469B;
.header {
  background: color;
}
.footer {
  composes: header;
  color: #FFF;
}
```

#### 16.jenkins  CI/CD（持续集成、持续部署） 

[jenkins](https://www.jianshu.com/p/5f671aca2b5a)

#### 17.大前端
大前端就是所有前端的统称，比如Android、iOS、web、Watch等，最接近用户的那一层也就是UI层，然后将其统一起来，就是大前端。
#### 18.微服务
[微服务](https://www.jianshu.com/p/0a3e959ecb81)
#### 19.算法排序
##### 冒泡排序
```
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```
##### 选择排序
```
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```
##### 插入排序
```
function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
```
##### 希尔排序
```
function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while(gap < len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap> 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i < len; i++) {
            temp = arr[i];
            for (var j = i-gap; j > 0 && arr[j]> temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
```
##### 快速排序
```
function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;

    if (left < right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}

function partition(arr, left ,right) {     //分区操作
    var pivot = left,                      //设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr, i, index);
            index++;
        }        
    }
    swap(arr, pivot, index - 1);
    return index-1;
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```
##### 归并排序
```
function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;
    if(len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];

    while (left.length>0 && right.length>0) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
```
##### 堆排序
```
var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) {   //建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &gt;= 0; i--) {
        heapify(arr, i);
    }
}

function heapify(arr, i) {     //堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left < len && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < len && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
    }
}

function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function heapSort(arr) {
    buildMaxHeap(arr);

    for (var i = arr.length-1; i > 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    }
    return arr;
}
```
##### 计数排序
```
function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue+1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i < arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }

    for (var j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
```
##### 基数排序
```
//LSD Radix Sort
var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}
```
##### 桶排序
```
function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }

    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i < arr.length; i++) {
      if (arr[i] < minValue) {
          minValue = arr[i];                //输入数据的最小值
      } else if (arr[i] > maxValue) {
          maxValue = arr[i];                //输入数据的最大值
      }
    }

    //桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            //设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;   
    var buckets = new Array(bucketCount);
    for (i = 0; i < buckets.length; i++) {
        buckets[i] = [];
    }

    //利用映射函数将数据分配到各个桶中
    for (i = 0; i < arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }

    arr.length = 0;
    for (i = 0; i < buckets.length; i++) {
        insertionSort(buckets[i]);                      //对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j < buckets[i].length; j++) {
            arr.push(buckets[i][j]);                      
        }
    }

    return arr;
}
```
#### 20.算法查找
##### 顺序查找
```
<script>
        function SequenceSearch(arr, value) {
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] == value) {
                    return i;
                }
            }
            return -1;
        }
        var arr = [1,3,4,5,2,4,2]
        console.log(SequenceSearch(arr,2))
</script>
```
##### 二分查找
```
<script>
        // 递归
        function binarySearch(data, dest, start, end) {
            if (start > end) { // 新增否则找不到进入死循环了
                return false;
            }
            var end = end || data.length - 1;
            var start = start || 0;
            var mid = Math.floor((start + end) / 2);
            //var mid = parseInt(start+(end-start)/2);
            //直接命中
            if (data[mid] == dest) {
                return mid;
            }

            if (data[mid] > dest) { // 放左
                end = mid - 1;
                return binarySearch(data, dest, start, end);
            } else { // 放右
                start = mid + 1;
                return binarySearch(data, dest, start, end);
            }
            return false;
</script>
```
```
<script>
        // 非递归 用while
        //代码中的判断条件必须是while (left <= right)，
        //否则的话判断条件不完整，比如：array[3] = {1, 3, 5};
        //待查找的键为5，此时在(low < high)条件下就会找不到，因为low和high相等时，指向元素5，但是此时条件不成立，没有进入while()中

        function binarySearch2(data, dest) {
            var end = data.length - 1;
            var start = 0;
            while (start <= end) {
                var m = Math.floor((end + 1) / 2);
                if (data[m] == dest) {
                    return m;
                }
                if (data[m] > dest) {
                    end = m - 1;
                } else {
                    start = m + 1;
                }
            }
            return falsex
    </script>
```
##### 插值查找
```
<script>
        function InsertionSearch(arr, val, start, end) {
            var end = end || data.length - 1;
            var start = start || 0;
            var mid = start + (val - arr[low]) / (arr[end] - arr[start]) * (end - start);
            if (arr[mid] == val) {
                return mid;
            }
            if (arr[mid] > val) {
                return InsertionSearch(arr, val, start, mid - 1);
            }
            else {
                return InsertionSearch(arr, val, mid + 1, end);
            }
        }
</script>
```
##### 斐波那契查找
```
<script>
        function getNum1(index) {
            if (index == 1 || index == 2) {
                return 1;
            } else {
                return getNum(index - 1) + getNum(index - 2);
            }
        }
        function getNum2(index) {
            if (index == 1 || index == 2) {
                return 1;
            } else {
                var one = 1;
                var two = 1;
                for (var i = 3; i <= index; i++) {
                    if (i == 3) {
                        one = 1;
                        two = 1;
                    }
                    else {
                        var temp = one;
                        one = two;
                        two = temp + two;
                    }
                }
                return one + two
            }
        }
        function getNum3(index) {
            var F = [];
            F[0] = 0;
            F[1] = 1;
            for (var i = 2; i < index - 1; i++) {
                F[i] = F[i - 1] + F[i - 2];
            }
            return F[index];
        }
</script>
```
```
<script>
        function search(array, value) {
            let low = 0, high = array.length - 1, n = array.length - 1;
            let mid, k = 0;
            //构建一个长度大于array数组的斐波那契数组
            var F = [];
            F[0] = 0;
            F[1] = 1;
            for (var i = 2; i < high + 5; i++) {
                F[i] = F[i - 1] + F[i - 2];
            }
            while (high > F[k] - 1) { //寻找第k项
                k++;
            }
            for (let i = high; i < F[k] - 1; i++) { //补全有序数组
                array[i] = array[high];
            }
            while (low <= high) {
                mid = low + F[k - 1] - 1;
                if (array[mid] > value) {
                    high = mid - 1;
                    k = k - 1; //长度缩减为F[k-1]-1
                } else if (array[mid] < value) {
                    low = mid + 1;
                    k = k - 2; //长度缩减为F[k-2]-1
                } else {
                    if (m <= n) //相等则找到位置
                        return mid;
                    else {
                        return n; //大于原始长度，则说明等于数组最后一项 
                    }
                }
                return -1;
            }
        }
</script>
```
##### 树表查找
##### 索引查找（分块查找
##### 哈希查找
##### 贪心算法
```
<script>
        function MinCoinChange(coins) {
            var coins = coins;
            var cache = {};
            this.makeChange = function (amount) {
                var change = [], total = 0;
                for (var i = coins.length; i >= 0; i--) {
                    var coin = coins[i];
                    while (total + coin <= amount) {
                        change.push(coin);
                        total += coin;
                    }
                }
                return change;
            }
        }
        var minCoinChange = new MinCoinChange([1, 5, 10, 25]);
        minCoinChange.makeChange(36);
        //一个25, 一个10, 一个1
</script>
```

