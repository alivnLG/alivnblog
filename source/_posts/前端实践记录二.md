---
title: 前端实践记录二
date: 2020-12-16 15:28:02
tags:
- WEB
categories:
- Web前端
---
#### 1.css制作三角形
<!--more-->
向上

```css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

向下

```css
#triangle-down {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-top: 100px solid red;
}
```

向左

```css
#triangle-left {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-right: 100px solid red;
    border-bottom: 50px solid transparent;
}
```

向右

```css
#triangle-right {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-left: 100px solid red;
    border-bottom: 50px solid transparent;
}
```

左上角

```css
#triangle-topleft {
    width: 0;
    height: 0;
    border-top: 100px solid red;
    border-right: 100px solid transparent;
}
```

右上角

```css
#triangle-topright {
    width: 0;
    height: 0;
    border-top: 100px solid red;
    border-left: 100px solid transparent;
 
}
```

左下角

```css
#triangle-bottomleft {
    width: 0;
    height: 0;
    border-bottom: 100px solid red;
    border-right: 100px solid transparent;
}
```

右下角

```css
#triangle-bottomright {
    width: 0;
    height: 0;
    border-bottom: 100px solid red;
    border-left: 100px solid transparent;
}
```

#### 2.calc函数

calc() 函数用于动态计算长度值。

- **需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；**

- 任何长度值都可以使用calc()函数进行计算；

- calc()函数支持 "+", "-", "*", "/" 运算；

- calc()函数使用标准的数学运算优先级规则；

#### 3.解析get参数

通过replace方法获取url中的参数键值对，可以快速解析get参数。

```js
const q = {};
location.search.replace(/([^?&=]+)=([^&]+)/g,(_,k,v)=>q[k]=v);
console.log(q); 
```

#### 4.解析链接url

可以通过创建a标签，给a标签赋值href属性的方式，获取到协议，pathname，origin等location对象上的属性。

```js
// 创建a标签
const aEle = document.createElement('a');
// 给a标签赋值href路径
aEle.href = '/test.html';
// 访问aEle中的属性
aEle.protocol; // 获取协议
aEle.pathname; // 获取path
aEle.origin;
aEle.host;
aEle.search;
...
```

#### 5.字符串常用方法

```js
includes();
```

字符串中是否包含某个字符串，这个不说了，其实就是indexOf的替代方案，用起来更优雅，

```js
startsWith();
```

字符串是否为某个字符串开始，我一般用它判断url是否有http

```js
endsWith();
```

字符串是否为某个字符串结尾。判断后缀名的时候尤其有效。

```js
repeat(number);
```

得到一个重复number次的字符串。额...我也不知道什么时候有用，一般我用它造测试数据。

```js
'abc'.padEnd(5, '1'); // abc11;
```

用给定的字符串在尾部拼接到指定长度，第一个参数为长度，第二个参数为用于拼接的值。

```js
'abc'.padStart(5, '1'); // 11abc;
```

用给定的字符串在首部拼接到指定长度第一个参数为长度，第二个参数为用于拼接的值。首部补0？

#### 6.数组快速去重

```js
const arr = [1, 2, 3, 4, 5, 6];

const arr2 = new Set(arr);

const arr3 = [...arr2];
```

#### 7.??合并空运算符

假设变量a不存在，我们希望给系统一个默认值，一般我们会使用||运算符。但是在javascript中空字符串，0，false都会执行||运算符，所以ECMAScript2020引入合并空运算符解决该问题，只允许在值为null或未定义时使用默认值。

```js
const name = '';

console.log(name || 'yd'); // yd;
console.log(name ?? 'yd'); // '';
```

#### 8.?可选链运算符

业务代码中经常会遇到这样的情况，a对象有个属性b, b也是一个对象有个属性c,

我们需要访问c，经常会写成 a.b.c，但是如果f不存在时，就会出错。

```js
const a = {
    b: {
        c: 123,
    }
}
console.log(a.b.c); // 123;
console.log(a.f.c); // f不存在所以会报错
```

```js
let person = {};
console.log(person?.profile?.age ?? 18); // 18
```

#### 9.0.1 + 0.2 === 0.3 // false

```js
console.log(0.1+0.2); // 0.30000000000000004
```

在JS当中，Number类型实际上是double类型，运算小数时存在精度问题。因为计算机只认识二进制，在进行运算时，需要将其他进制的数值转换成二进制，然后再进行计算

小数用二进制表达时是无穷的。

```js
// 将0.1转换成二进制
console.log(0.1.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101

// 将0.2转换成二进制
console.log(0.2.toString(2));  // 0.001100110011001100110011001100110011001100110011001101
```

双精度浮点数的小数部分最多支持53位二进制位，所以两者相加后，因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004，这样在进行算术计算时会产生误差。

ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于64位浮点数来说，大于1的最小浮点数相当于二进制的1.00..001，小数点后面有连续51个零。这个值减去1之后，就等于2的-52次方。

```js
Number.EPSILON === Math.pow(2, -52)
// true
Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// "0.00000000000000022204"
```

Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。
引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。

Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。

```js
(0.1 + 0.2 - 0.3) < Number.EPSILON // true
```

#### 10.JavaScript为什么是单线程

一个简单的原因就是，js在设计之初只是进行一些简单的表单校验，这完全不需要多线程，单线程完全可以胜任这项工作。即便后来前端发展迅速，承载的能力越来越多，也没有发展到非多线程不可的程度。

而且还有一个主要的原因，设想一下，如果js是多线程的，在运行时多个线程同时对DOM元素进行操作，那具体以哪个线程为主就是个问题了，线程的调度问题是一个比较复杂的问题。

HTML5新的标准中允许使用new Worker的方式来开启一个新的线程，去运行一段单独的js文件脚本，但是在这个新线程中严格的要求了可以使用的功能，比如说他只能使用ECMAScript, 不能访问DOM和BOM。这也就限制死了多个线程同时操作DOM元素的可能。
