---
title: 前端安全详解
date: 2020-011-25 12:00:59
tags:
- DDOS
- XSS
- CSRF
- SQL
categories:
- 网络安全
---
####  一、XSS攻击
##### 1.1 定义

跨站脚本攻击(XSS),英文全称 Cross Site Script, 是Web安全头号大敌。
<!--more-->
XSS攻击，一般是指黑客通过在网页中注入恶意脚本，当用户浏览网页时，恶意脚本执行，控制用户浏览器行为的一种攻击方式。

因为缩写和CSS重叠，所以只能叫XSS，跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。

##### 1.2 攻击实例

假设我们页面中存在一个input或者textarea用来收集用户输入的数据，正常情况下不会有什么问题，假设用户输入的内容为 

```js
<script>alert(1)</script>
```

当我们将用户输入的这段内容通过innnerHTML添加到页面中时，就会运行该段代码，弹出alert。

```js
document.body.innerHTML = inputValue;
```

可以发现，用户输入的js脚本是可以被执行的，这样的话就形成了一个安全漏洞，很多黑客都是先通过alert的方式先去试验网站是否可以被XSS，这也就意味着可以运行js里面的任何脚本。

用户在不知情的情况下输入的账号密码会被黑客记录发送给自己，也可以通过js改写页面显示非法图片，将用户的登录状态复制到黑客的电脑上黑客可以使用用户的身份进行操作等等。

##### 1.3 攻击方式

XSS攻击通常分为：

- **存储型XSS**
- **反射型XSS**
- **DOM Based XSS**

###### 存储型XSS

上面介绍的通过input输入的方式进行攻击叫做存储型，就是用户输入的内容会存储到数据库，每次打开页面都会执行。

存储型XSS又被称为持久性XSS,会把黑客输入的恶意脚本存储在服务器的数据库中。当其他用户浏览页面包含这个恶意脚本的页面，用户将会受到黑客的攻击。一个常见的场景就是黑客写下一篇包含恶意JavaScript脚本的博客文章，当其他用户浏览这篇文章时，恶意的JavaScript代码将会执行。

###### 反射型XSS

通过url参数攻击叫做反射型

反射型XSS也被称为非持久性XSS,这种攻击方式把XSS的Payload写在URL中，通过浏览器直接“反射"给用户。这种攻击方式通常需要诱使用户点击某个恶意链接，才能攻击成功。

假设我们网站url中携带的内容会渲染到页面。

```js
http://localhost:8080/index.html?name=yd

```
黑客可以发送如下的链接给用户，用户一旦打开就会执行脚本。

```js
http://localhost:8080/index.html?name=<script>alert(123)</script>
```

###### DOM Based XSS

DOM Based XSS是一种利用前端代码漏洞进行攻击的攻击方式。前面的反射型XSS与存储型XSS虽然恶意脚本的存放位置不同，但其本质都是利用后端代码的漏洞。

##### 1.4 XSS的危害

- 1.获取页面数据
- 2.获取Cookies
- 3.修改前端逻辑
- 4.发送请求
- 5.获取用户的信息和登录态
- 6.欺骗用户

##### 1.5 防止XSS攻击

（1）可以在header中设置响应头 X-XSS-Protection，默认情况下禁止XSS攻击的，如果检测到url中存在XSS攻击，页面是拒绝访问的。但是他对存储型的攻击是无效的，只能拦截url中存在注入攻击的情况。

```js
ctx.set('X-XSS-Protection', 0); // 允许XSS攻击
```

值有如下4种:

- 0 允许XSS攻击
- 1 禁止XSS攻击。如果检测到跨站脚本攻击，浏览器将清除页面(删除不安全的部分)
- 1;mode=block 启用XSS过滤，如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。
- 1report= 启用XSS过滤，如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri 指令的功能发送违规报告。

通常情况下浏览器会默认设置为1，禁止XSS攻击。

（2）CSP

内容安全策略(CSP Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括XSS和数据注入等攻击。这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。

CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行，我们只需要配置规则，如何拦截是浏览器自己实现的，我们可以通过这种方式来尽量减少XSS攻击。

这个策略他有如下几种方式:

```js
// 只允许加载本站资源
Content-Security-Policy: default-src 'self'

// 只允许加载HTTPS协议图片
Content-Security-Policy: img-src https://*

// 不允许加载任何来源框架
Content-Security-Policy: child-src 'none'
```

一般被攻击是我们的网站执行了其他网站的js脚本，注入了黑客的js代码。假设我们的网站设置了只允许加载自己网站的代码，那么注入的js脚本就没办法执行了。

```js
// 设置只允许执行自己网站的js脚本，
ctx.set('Content-Security-Policy', "default-src 'self'")

// 浏览器打开连接时4000端口的外部资源不能被加载
https://127.0.0.1:3000?from=<script src="http://127.0.0.1:4000/hack.js"></script>
```

（3）转译字符

用户输入永远不可信任的，最普遍的做法就是转译输出的内容，对于引号，尖括号，斜杠进行转译，比如通过如下的函数，对用户输入的内容进行转译。

```js
function escape(str) {
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quto;');
    str = str.replace(/'/g, '&#39;');
    str = str.replace(/`/g, '&#96;');
    str = str.replace(/\//g, '&#x2F;');
    return str;
}

escape('<script>alert(123)</script>'); // &lt;script&gt;alert(123)&lt;&#x2F;script&gt;
```

这种转译叫做黑名单注意，就是把不安全的东西进行转译，比如说<>, 但是有一种情况是不能进行黑名单转译的。

有时我们要处理一些富文本，显然不能通过上面的办法来转译所有字符，因为这样会把需要的格式也过滤掉，对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

白名单的方式就是允许一部分安全的字符通过，其他的字符全部转译，这里推荐使用xss的npm包来处理。

```js
// 引入xss
const xss = require('xss');

let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss")</script>');

// <h1 id="title">XSS Demo</h1>&lt;script&gt;alert("xss")&lt;/script&gt;

console.log(html);
```

可以看到这里xss保留了h1标签，因为他是安全的，对script标签进行了转译，因为他是不全安的。

一般情况用户输入的数据或者从url中获取的参数我们不建议直接使用innnerHTML插入到页面中，除了xss模块和escape方法还可以引入html模板，常见的是ejs模板。react,vue,angular等框架默认已经帮我们处理了xss。

```html
// 转译 inputValue 内容
<%= inputValue %>

// 不转移 inputValue 内容
<%- inputValue %>
```

（4）HttpOnly Cookie

为什么用户的cookie可以被调取，原因是js是可以获取cookie的，我们可以通过禁止js访问cookie的方式防范这种攻击。

这是预防XSS攻击窃取用户cookie最有效的防御手段，Web应用程序在设置cookie时，将其属性设为HttpOnly, 就可以避免该网页的cookie被客户端恶意javaScript窃取，保护用户cookie信息。也就是服务在设置cookie的时候跟上HttpOnly即可。

```js
response.addHeader('Set-Cookie', 'uid=112; path/; HttpOnly')
```

这样设置的cookie，js就没办法访问到了。

#### 二、CSRF

##### 2.1 定义

CSRF( Cross Site Request Forgery)，即跨站请求伪造，是一种常见的web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义来完成非法操作。

跨站请求伪造（Cross-site request forgery）  
XSS攻击是利用盗取的高权限cookie来进行的，相较而言CSRF并不干偷盗之事，而是借刀杀人，利用CSRF攻击就是借用用户的身份去执行用户的操作  

##### 2.2 攻击实例

用户已经登录了站点A, 并且在A站点记录了登录状态(cookie)，再次进来不需要登录了。在用户没有登出站点A的情况下，也就是登录态还有效时，访问了恶意攻击者提供的引诱危险站点B, B站点调用A站点的某个接口，比如说提交接口。如果A站点没有做任何的CSRF防御，就会被攻击。

原理也很简单，因为B站点调用了A站点的提交接口，根据cookie匹配原则，调用哪个站点的接口就会携带哪个站点的cookie，携带的就是用户存在A站点的cookie，这个时候提交接口传递的参数实际上是B站点提供的。在用户无意识的情况下以用户的身份调用了接口。

很多人可能会觉得，B站点调用A站点的接口跨域了啊，那怎么行。这没什么，跨域只是一种说法而已一般的跨域是前端拿不到接口的返回值，但不代表请求发不出去，这种攻击只要请求发出去了就达到攻击的目的了，返回值什么的都无所谓了。

##### 2.3 防止CSRF攻击

CSRF防御原则：  

- **GET方式不能用于更新资源的操作**
- **POST方式请求加上随机token验证**

第一个是禁止第三方网站携带Cookie，但是有兼容性问题

第二个方式是验证请求传递过来的referrer，判断是不是一个合法的referrer。其实很多的防盗链都是验证referrer的方式。
referrer就是发送请求的那个前端页面地址，可以通过referrer的方法进行屏蔽和过滤，但是他也有一个问题https是不发送referrer的，所以也算是兼容性的问题。

目前最有效的方式还是验证码的方式或者人机交互的方式，以前可以通过CSRF调取用户资金，因为转账比较简单，但现在基本转账都会发送验证码之类的验证。

#### 3.DDOS攻击
分布式拒绝服务（DDoS）攻击是一种恶意企图，通过大量互联网流量压倒目标或其周围的基础架构来破坏目标服务器，服务或网络的正常流量。DDoS攻击通过利用多个受损计算机系统作为攻击流量来源来实现有效性。被利用的机器可以包括计算机和其他网络资源，例如物联网设备。从高层次来看，DDoS攻击就像堵塞高速公路的交通堵塞，阻止了常规交通到达其所需的目的地。  

DDoS攻击需要攻击者控制在线计算机网络才能进行攻击。计算机和其他计算机（如物联网设备）感染了恶意软件，将每个计算机转变为机器人（或僵尸）。然后，攻击者可以远程控制僵尸程序组，这称为僵尸网络。

一旦僵尸网络建立，攻击者就可以通过远程控制方法向每个机器人发送更新的指令来指导机器。当受害者的IP地址被僵尸网络作为目标时，每个僵尸程序将通过向目标发送请求来响应，可能导致目标服务器或网络溢出容量，从而导致对正常流量的拒绝服务。由于每个机器人都是合法的Internet设备，因此将攻击流量与正常流量分开可能很困难。


#### 4.SQL注入攻击
SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的SQL服务器加以解析并执行。

原因：对构造成SQL语句的变量，过滤不严格，造成可以构造任意的SQL语句，传递到数据库执行。

产生地方：get query string  请求query参数    port string  端口    http header 请求头部


<br/>
<br/>
<br/>

转载自：[https://juejin.cn/post/6898691314351603720](https://juejin.cn/post/6898691314351603720)