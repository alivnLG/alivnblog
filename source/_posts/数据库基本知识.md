---
title: 数据库基本知识
date: 2020-05-29 11:04:53
tags:
- Oracle
- DB2
- Microsoft SQL Server
- Microsoft Access
- MySQL
categories:
- 数据库
---
### 一、关系型数据库
#### 产品
Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL
<!--more-->
#### 遵循ACID规则
##### 1、A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。

比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。
##### 2、C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。

例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。
##### 3、I (Isolation) 独立性
所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。

比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。
##### 4、D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。

#### 扩展
通常是纵向扩展，但到达一定程度时只能横向扩展。

关系型数据库的横向扩展支持三种方法，即主从复制，集群和分片(sharding)。

![database001](http://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/database001.jpg)

##### 1.主从复制
主从复制(Master-slave replication)，最易配置，对应用改动最小，并可以减轻主库的负担。

主数据库可以读写，从数据库只读。最常用的场景就是实现读写分离，或业务分离，即运行报表，备份，数据仓库等应用。

这种方法的问题是主与从之间数据非完全同步，可能会读到两个不同的版本。另一个问题是，如果只有主库接受读写，那么主库迟早会过载，因此不算是真正的scale out。

不过主从库数据的延迟，有的业务是可以接受的。另外，利用一些实时复制的工具如GoldenGate，从库也是可以写的，这时可以利用从库做其它的业务，从而达到横向扩展的目的。这也算是主从复制的一个新趋势。

##### 2.集群(Clustering)
集群也称为shared everything或shared disk架构。最知名的就是Oracle RAC。

1个数据库可以有多个实例，来访问共享存储上的数据库。

每一个节点都可以读写，从应用角度来看，代码无需改变。负载均衡也是自动的。

###### 集群存在的问题包括：

* 写数据时需要内存中数据的同步，数据加速带来竞争，影响扩展性

* 难以设置和管理

* 由于存储是共享的，读操作也不能无限扩展

集群适合于读密集的应用，如数据仓库和大数据BI。

##### 3.分片(Sharding)
分区(Partition)是库内的，分片(Sharding)是库外的，也叫分表分库, 是shared nothing的架构。

Sharding即将一个大的库拆分成很多小库。如何拆和业务规则有关，可以按用户ID拆，按业务拆。如果需要Join，相关的表需要放到一个库里，避免数据库间的通讯。

###### Sharding也可以有两种方法，即垂直分区和水平分区。
水平分区则是将一个大表拆分为小表，每个小表位于不同的库。每一个建立相同的schema。如根据主键的hash值来分区。

###### sharding的不足在于：

* 加大了应用代码的复杂性，需要路由到正确的shard。

* 后期增加shard需要修改应用逻辑，并需要迁移数据

* 查询和聚集(aggregation)不再简单，需要跨库联合操作

* 主数据和参照数据需要复制到所有shard，以避免跨库操作。主数据和参照数据虽然偏静态，但一旦修改，可能会有数据一致性问题。

* 跨库修改需要分布式交易处理，会限制可扩展性。因此应尽量避免。

* 单个shard的失效可能会使整个系统不可用(其实也不一定)。因此通常需要为每个shard再配置HA方案，如主从复制。

分片对于一些大型网站还是广泛使用，如Google, eBay, Facebook, Flickr。

#### 优点/缺点
优点：
- 容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；
- 使用方便：通用的SQL语言使得操作关系型数据库非常方便；
- 易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
- 支持SQL，可用于复杂的查询。

缺点：
- 为了维护一致性所付出的巨大代价就是其读写性能比较差；
- 固定的表结构；
- 不适合高并发读写需求；
- 不方便海量数据的高效率读写；
　　
### 二、非关系型数据库
#### 产品
NoSql、Cloudant、MongoDb、redis、HBase

NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。

#### 特征
##### 使用键值对存储数据；
##### 分布式；
##### 一般不支持ACID特性；
##### 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。
　　
#### 优点/缺点
优点:
- 无需经过sql层的解析，读写性能很高
- 基于键值对，数据没有耦合性，容易扩展
- 分布式计算
- 低成本
- 架构的灵活性，半结构化数据
- 没有复杂的关系
- 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。

缺点:
- 没有标准化
- 有限的查询功能（到目前为止）
- 最终一致是不直观的程序
- 无事务处理


### 三、横向扩展、纵向扩展
##### 横向扩展 也叫 水平扩展，用更多的节点支撑更大量的请求。 如成千上万的蚂蚁完成一项搬运工作

##### 纵向扩展 又叫 垂直扩展，扩展一个点的能力支撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车

##### 横向扩展：多增加几台API服务器，一起服务。
##### 纵向扩展：把API服务器换成性能更好的机器。

### 四、集中式计算、分布式计算、协作式计算
随着计算技术的发展，有些应用需要非常巨大的计算能力才能完成，如果采用集中式计算，需要耗费相当长的时间来完成。
#### 集中式计算
集中式计算几乎完全依赖于一台大型的中心计算机的处理能力，这台中心 机称为主机(Host or mainframe)。
#### 分布式计算
分布式计算将该应用分解成许多小的部分，分配给多台计算机进行处理。这样可以节约整体计算时间，大大提高计算效率。

分布式计算机中主机处理的大多是其内部任务，大量的任务由智能的终端去完成。网络上所有计算机都有处理能力，每个新加人的用户都对网络处理能力的提高有贡献，可以使用网上多台计算机来完成一个共同的处理任务。

如果某一台计算机脱离了网络(发生故障或关机)对网上的其他用户不会有大的影响。

#### 协作式计算
可以看作为一种协作式的分布计算，计算机之间不仅仅像在分布式计算中那样互相传递数据，实现信息共享，而且要进行更深层次的共享，也就是说用两台或更多的计算机来共同完成一个处理任务。

协同式计算是实现真正网络协同的重要一步。网络协同是指网络的处理能力要比网络中所有处理器处理能力的直接相加的和更大。

##### 协同式计算的两个最重要的特征是对称处理和并行处理。

对称处理是由多个处理器协同地进行某一过程，各处理器之间的负载是平衡的，当然由于对称处理实现的困难性，目前还没有哪一种网络完全实现对称处理。

并行处理，即多任务处理，是指几个不同的任务在联网的处理器之中同时地，即并行地，进行处理。

### 五、事务
#### 1.简介
事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。

#### 2.特征
##### 遵循ACID
##### 隔离级别
不同的隔离级别对事务的处理不同。4个隔离级别分别是：

###### 读未提及（READ_UNCOMMITTED）
该隔离级别允许脏读取，其隔离级别是最低的。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务；而以此同时，允许另一个事务也能够访问该数据。

脏读示例：

在事务A和事务B同时执行时可能会出现如下场景：

时间 | 事务A（存款） | 事务B（取款）
--|--|--
T1 | 开始事务 | ——
T2 | —— | 开始事务
T3 | —— | 查询余额（1000元）
T4 | —— | 取出1000元（余额0元）
T5 | 查询余额（0元） | ——
T6 | —— | 撤销事务（余额恢复1000元）
T7 | 存入500元（余额500元） | ——
T8 | 提交事务 | ——

余额应该为1500元才对。请看T5时间点，事务A此时查询的余额为0，这个数据就是脏数据，他是事务B造成的，很明显是事务没有进行隔离造成的。

###### 读已提交（READ_COMMITTED）
读已提交是不同的时候执行的时候只能获取到已经提交的数据。
这样就不会出现上面的脏读的情况了。

不可重复读示例：

可是解决了脏读问题，但是还是解决不了可重复读问题。

时间 | 事务A（存款） | 事务B（取款）
--|--|--
T1 | 开始事务 | ——
T2 | —— | 开始事务
T3 | —— | 查询余额（1000元）
T4 | 查询余额（1000元） | ——
T5 | —— | 取出1000元（余额0元）
T6 | —— | 提交事务
T7 | 查询余额（0元） | ——
T8 | 提交事务 | ——
事务A其实除了查询两次以外，其它什么事情都没做，结果钱就从1000编程0了，这就是不可重复读的问题。

###### 可重复读（REPEATABLE_READ）
可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别进制了不可重复读取和脏读，但是有可能出现幻读的数据。

幻读就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。

时间 | 事务A（统计总存款） | 事务B（存款）
--|--|--
T1 | 开始事务 | ——
T2 | —— | 开始事务
T3 | 统计总存款（1000元） | ——
T4 | —— | 存入100元
T5 | —— | 提交事务
T6 | 提交总存款（10100） | ——
T7 | 提交事务 | ——

银行工作人员在一个事务中多次统计总存款时看到结果不一样。如果要解决幻读，那只能使用顺序读了。

###### 顺序读（SERIALIZABLE）。
顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。

##### 事务隔离级别对比
事务隔离级别 | 脏 读 | 不可重复读 | 幻 读
--|--|--|--
读未提及（READ_UNCOMMITTED） | 允许 | 允许 | 允许
读已提交（READ_COMMITTED） | 禁止 | 允许 | 允许
可重复读（REPEATABLE_READ） | 禁止 | 禁止 | 允许
顺序读（SERIALIZABLE） | 禁止 | 禁止 | 禁止

4种事务隔离级别从上往下，级别越高，并发性越差，安全性就越来越高。

一般数据默认级别是读以提交或可重复读。

#### 3.思维导图
![database002](http://alivnram-test.oss-cn-beijing.aliyuncs.com/alivnblog/database002.jpg)
